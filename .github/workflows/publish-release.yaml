name: Publish Release

on:
  push:
    branches:
      - main

jobs:
  publish_release:
    name: Publish Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    # Note: `prepare-release.yaml` creates PR with branch name containing 'prepare-release'
    if: ${{ contains(github.event.head_commit.message, 'release core packages') }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: ./.github/actions/setup-and-build

      # sets steps.resolve-release-version.outputs.version based on upstream package.json
      - uses: ./.github/actions/resolve-release-version
        id: resolve-release-version

      - name: Read fork version
        id: fork-version
        run: |
          FORK_VERSION=$(cat .tutorialkit-rb-version)
          echo "FORK_VERSION=$FORK_VERSION" >> $GITHUB_ENV
          echo "fork-version=$FORK_VERSION" >> $GITHUB_OUTPUT
          echo "Fork version: $FORK_VERSION"

      - name: Update package names and versions for Ruby fork
        run: |
          # Function to update package.json
          update_package_json() {
            local pkg_path=$1
            local pkg_json="${pkg_path}/package.json"

            if [ ! -f "$pkg_json" ]; then
              return
            fi

            # Create backup
            cp "$pkg_json" "${pkg_json}.bak"

            # Read current package name
            local current_name=$(node -pe "require('./${pkg_json}').name")

            # Check if we have a mapping for this package
            local new_name=""
            case "$current_name" in
              "@tutorialkit/astro") new_name="@tutorialkit-rb/astro" ;;
              "@tutorialkit/react") new_name="@tutorialkit-rb/react" ;;
              "@tutorialkit/runtime") new_name="@tutorialkit-rb/runtime" ;;
              "@tutorialkit/theme") new_name="@tutorialkit-rb/theme" ;;
              "@tutorialkit/types") new_name="@tutorialkit-rb/types" ;;
              "@tutorialkit/cli") new_name="@tutorialkit-rb/cli" ;;
              "test-utils") new_name="@tutorialkit-rb/test-utils" ;;
              "create-tutorial") new_name="create-tutorialkit-rb" ;;
              *) echo "No mapping for $current_name, skipping..."; return ;;
            esac

            echo "Updating $current_name to $new_name"

            # Update package name, version, dependencies, and repo info using Node.js
            node -e "
              const fs = require('fs');
              const path = require('path');
              const pkg = require(path.resolve('${pkg_json}'));

              // Dynamic Versioning Logic: [upstream-version]-rb.[fork-version]
              const upstreamVersion = pkg.version;
              const forkVersion = process.env.FORK_VERSION; // Get fork version from env

              if (forkVersion) {
                pkg.version = \`\${upstreamVersion}-rb.\${forkVersion}\`;
                console.log(\`Updated version to: \${pkg.version}\`);
              } else {
                console.warn('FORK_VERSION not set. Publishing with upstream version.');
              }

              // Update package name
              pkg.name = '${new_name}';

              // Update dependencies to point to fork packages
              const nameMapping = {
                '@tutorialkit/astro': '@tutorialkit-rb/astro',
                '@tutorialkit/react': '@tutorialkit-rb/react',
                '@tutorialkit/runtime': '@tutorialkit-rb/runtime',
                '@tutorialkit/theme': '@tutorialkit-rb/theme',
                '@tutorialkit/types': '@tutorialkit-rb/types',
                '@tutorialkit/cli': '@tutorialkit-rb/cli',
                '@tutorialkit/test-utils': '@tutorialkit-rb/test-utils',
                'create-tutorial': 'create-tutorialkit-rb'
              };

              ['dependencies', 'devDependencies', 'peerDependencies'].forEach(depType => {
                if (pkg[depType]) {
                  Object.keys(pkg[depType]).forEach(dep => {
                    if (nameMapping[dep]) {
                      const version = pkg[depType][dep];
                      delete pkg[depType][dep];
                      pkg[depType][nameMapping[dep]] = version;
                    }
                  });
                }
              });

              // Add repository info for Ruby fork
              pkg.repository = {
                type: 'git',
                url: 'https://github.com/Bakaface/tutorialkit.rb',
                directory: '${pkg_path}'
              };

              // Add Ruby fork keywords
              if (!pkg.keywords) pkg.keywords = [];
              if (!pkg.keywords.includes('ruby')) pkg.keywords.push('ruby');
              if (!pkg.keywords.includes('rails')) pkg.keywords.push('rails');
              if (!pkg.keywords.includes('wasm')) pkg.keywords.push('wasm');

              // Replace workspace:* references with actual versions
              ['dependencies', 'devDependencies', 'peerDependencies'].forEach(depType => {
                if (pkg[depType]) {
                  Object.keys(pkg[depType]).forEach(dep => {
                    if (pkg[depType][dep] === 'workspace:*') {
                      pkg[depType][dep] = pkg.version;
                    }
                  });
                }
              });

              fs.writeFileSync('${pkg_json}', JSON.stringify(pkg, null, 2));
            "
          }

          # Update all packages in the workspace
          for pkg_dir in packages/*; do
            if [ -d "$pkg_dir" ]; then
              update_package_json "$pkg_dir"
            fi
          done
        env:
          FORK_VERSION: ${{ env.FORK_VERSION }}

      - name: Update source code imports
        run: |
          echo "Updating source code imports..."

          find packages -name "*.ts" -o -name "*.js" -o -name "*.mts" -o -name "*.mjs" | xargs sed -i \
            -e "s/@tutorialkit\/astro/@tutorialkit-rb\/astro/g" \
            -e "s/@tutorialkit\/react/@tutorialkit-rb\/react/g" \
            -e "s/@tutorialkit\/runtime/@tutorialkit-rb\/runtime/g" \
            -e "s/@tutorialkit\/theme/@tutorialkit-rb\/theme/g" \
            -e "s/@tutorialkit\/types/@tutorialkit-rb\/types/g" \
            -e "s/@tutorialkit\/cli/@tutorialkit-rb\/cli/g" \
            -e "s/@tutorialkit\/test-utils/@tutorialkit-rb\/test-utils/g"

          echo "Source code imports updated"

      - name: Publish to npm
        run: |
          # Publish each package with the renamed version
          for pkg_dir in packages/*; do
            if [ -f "$pkg_dir/package.json" ]; then
              pkg_name=$(node -pe "require('./${pkg_dir}/package.json').name")

              # Only publish if it's a renamed package under the new scope
              if [[ "$pkg_name" == @tutorialkit-rb/* ]] || [[ "$pkg_name" == "create-tutorialkit-rb" ]]; then
                echo "Publishing $pkg_name..."
                (cd "$pkg_dir" && npm publish --provenance --access public) || echo "Failed to publish $pkg_name"
              fi
            fi
          done
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Update CLI template versions
        working-directory: ./packages/cli
        run: pnpm build-release
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Restore original package.json files
        if: always()
        run: |
          # Restore all backup files to avoid committing temporary changes
          for backup in packages/**/package.json.bak; do
            if [ -f "$backup" ]; then
              original="${backup%.bak}"
              mv "$backup" "$original"
              echo "Restored $original"
            fi
          done

      - name: Create and push git tag
        run: |
          FULL_VERSION="${{ steps.resolve-release-version.outputs.version }}-rb.${{ env.FORK_VERSION }}"

          git config --global user.name 'github-actions'
          git config --global user.email 'github-actions@users.noreply.github.com'
          git tag $FULL_VERSION
          git push origin $FULL_VERSION
